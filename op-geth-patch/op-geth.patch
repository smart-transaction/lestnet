diff --git a/cmd/geth/config.go b/cmd/geth/config.go
index c6d14f369..15e1b153d 100644
--- a/cmd/geth/config.go
+++ b/cmd/geth/config.go
@@ -205,6 +205,8 @@ func makeFullNode(ctx *cli.Context) *node.Node {
 		cfg.Eth.OverrideVerkle = &v
 	}
 
+	log.Info("Registering eth service", "state scheme", cfg.Eth.StateScheme)
+
 	backend, eth := utils.RegisterEthService(stack, &cfg.Eth)
 
 	// Create gauge with geth system and build information
diff --git a/cmd/utils/flags.go b/cmd/utils/flags.go
index a82aad387..6961f43e7 100644
--- a/cmd/utils/flags.go
+++ b/cmd/utils/flags.go
@@ -1839,7 +1839,10 @@ func SetEthConfig(ctx *cli.Context, stack *node.Node, cfg *ethconfig.Config) {
 		cfg.StateHistory = ctx.Uint64(StateHistoryFlag.Name)
 	}
 	if ctx.IsSet(StateSchemeFlag.Name) {
+		log.Info("Flag --state.scheme is set", "flag", StateSchemeFlag.Value)
 		cfg.StateScheme = ctx.String(StateSchemeFlag.Name)
+	} else {
+		log.Info("Flag --state.scheme is NOT set")
 	}
 	// Parse transaction history flag, if user is still using legacy config
 	// file with 'TxLookupLimit' configured, copy the value to 'TransactionHistory'.
diff --git a/core/rawdb/accessors_trie.go b/core/rawdb/accessors_trie.go
index 44eb715d0..60fcbdc5f 100644
--- a/core/rawdb/accessors_trie.go
+++ b/core/rawdb/accessors_trie.go
@@ -283,6 +283,7 @@ func ParseStateScheme(provided string, disk ethdb.Database) (string, error) {
 	// If state scheme is not specified, use the scheme consistent
 	// with persistent state, or fallback to hash mode if database
 	// is empty.
+	log.Info("Provided state scheme:", "provided", provided)
 	stored := ReadStateScheme(disk)
 	if provided == "" {
 		if stored == "" {
diff --git a/eth/backend.go b/eth/backend.go
index feeb00678..8d91d4cdc 100644
--- a/eth/backend.go
+++ b/eth/backend.go
@@ -110,6 +110,7 @@ type Ethereum struct {
 // New creates a new Ethereum object (including the initialisation of the common Ethereum object),
 // whose lifecycle will be managed by the provided node.
 func New(stack *node.Node, config *ethconfig.Config) (*Ethereum, error) {
+	log.Info("Entering New()", "stateScheme", config.StateScheme)
 	// Ensure configuration values are compatible and sane
 	if !config.SyncMode.IsValid() {
 		return nil, fmt.Errorf("invalid sync mode %d", config.SyncMode)
